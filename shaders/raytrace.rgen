#version 460
#extension GL_EXT_ray_tracing : enable
#extension GL_EXT_buffer_reference2 : require
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_debug_printf : enable

#include "types.glsl"
#include "functions.glsl"


layout(binding = 0, set = 0) uniform accelerationStructureEXT topLevelAS;
layout(binding = 1, set = 0, rgba32f) uniform image2D image;
layout(location = 0) rayPayloadEXT HitPayload rayPayload;

layout(scalar, binding = 2, set = 0) uniform CameraData{
  vec3 origin;
  vec3 orientation;
} camera;

layout(buffer_reference, std430) readonly buffer VertexBuffer
{
    Vertex vertices[];
};

layout(buffer_reference, std430) readonly buffer IndexBuffer
    {
        uint indices[];
    };


//push constants block
layout(scalar, push_constant) uniform RayPushConstants push;


// const vec3 origin = vec3(0., 0., -10.);
const float Ft = 0.700207531;

const uint rayFlags = gl_RayFlagsOpaqueEXT;
const float tMin = 0.001;
const float tMax = 10000.;

void main() 
{
    const float h = gl_LaunchSizeEXT.y;
    const float w = gl_LaunchSizeEXT.x;
    const float i = gl_LaunchIDEXT.y;
    const float j = gl_LaunchIDEXT.x;
    const float hm1 = h - 1.;
    const float wm1 = w - 1.;
    const float arFt = (w / h) * Ft;

    const float y = (-1. + 2. * (i + 0.5f) / hm1) * Ft;
    const float x = (-1. + 2. * (j + 0.5f) / wm1) * arFt;

    const vec3 forward = camera.orientation;
    vec3 up = vec3(0.0, -1.0, 0.0);
    const vec3 right = cross(forward, up);
    up = cross(forward, right);   // re-orthonormalize

    vec3 pixelCam = normalize(vec3(x, y, 1.)); // camera-space ray
    const vec3 direction = pixelCam.x * right + pixelCam.y * up + pixelCam.z * forward;

    const vec3 origin = camera.origin;

    rayPayload.depth = 0;
    rayPayload.hitValue = vec3(0.);
    traceRayEXT(topLevelAS, // acceleration structure
      rayFlags, // rayFlags
      0xFF, // cullMask
      0, // sbtRecordOffset
      0, // sbtRecordStride
      0, // missIndex
      origin, // ray origin
      tMin, // ray min range
      direction, // ray direction
      tMax, // ray max range
      0 // payload (location = 0)
    );

    imageStore(image, ivec2(j, i), vec4(rayPayload.hitValue, 1.));
}
